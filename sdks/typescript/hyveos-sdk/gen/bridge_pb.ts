// Put the basic example for grpc using proto2 here

// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file bridge.proto (package bridge, syntax proto2)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message as Message$1 } from "@bufbuild/protobuf";

/**
 * Describes the file bridge.proto.
 */
export const file_bridge: GenFile = /*@__PURE__*/
  fileDesc("CgxicmlkZ2UucHJvdG8SBmJyaWRnZSIHCgVFbXB0eSIUCgREYXRhEgwKBGRhdGEYASACKAwiKgoMT3B0aW9uYWxEYXRhEhoKBGRhdGEYASABKAsyDC5icmlkZ2UuRGF0YSISCgJJRBIMCgR1bGlkGAEgAigJIhcKBFBlZXISDwoHcGVlcl9pZBgBIAIoCSIWCgVUb3BpYxINCgV0b3BpYxgBIAIoCSItCg1PcHRpb25hbFRvcGljEhwKBXRvcGljGAEgASgLMg0uYnJpZGdlLlRvcGljIkYKClRvcGljUXVlcnkSHgoFdG9waWMYASABKAsyDS5icmlkZ2UuVG9waWNIABIPCgVyZWdleBgCIAEoCUgAQgcKBXF1ZXJ5IjcKEk9wdGlvbmFsVG9waWNRdWVyeRIhCgVxdWVyeRgBIAEoCzISLmJyaWRnZS5Ub3BpY1F1ZXJ5IksKB01lc3NhZ2USGgoEZGF0YRgBIAIoCzIMLmJyaWRnZS5EYXRhEiQKBXRvcGljGAIgAigLMhUuYnJpZGdlLk9wdGlvbmFsVG9waWMiRwoLU2VuZFJlcXVlc3QSGgoEcGVlchgBIAIoCzIMLmJyaWRnZS5QZWVyEhwKA21zZxgCIAIoCzIPLmJyaWRnZS5NZXNzYWdlIlQKC1JlY3ZSZXF1ZXN0EhoKBHBlZXIYASACKAsyDC5icmlkZ2UuUGVlchIcCgNtc2cYAiACKAsyDy5icmlkZ2UuTWVzc2FnZRILCgNzZXEYAyACKAQiRQoIUmVzcG9uc2USHAoEZGF0YRgBIAEoCzIMLmJyaWRnZS5EYXRhSAASDwoFZXJyb3IYAiABKAlIAEIKCghyZXNwb25zZSI/CgxTZW5kUmVzcG9uc2USCwoDc2VxGAEgAigEEiIKCHJlc3BvbnNlGAIgAigLMhAuYnJpZGdlLlJlc3BvbnNlIiQKBVBlZXJzEhsKBXBlZXJzGAEgAygLMgwuYnJpZGdlLlBlZXIiegoOTmVpZ2hib3VyRXZlbnQSHQoEaW5pdBgBIAEoCzINLmJyaWRnZS5QZWVyc0gAEiIKCmRpc2NvdmVyZWQYAiABKAsyDC5icmlkZ2UuUGVlckgAEhwKBGxvc3QYAyABKAsyDC5icmlkZ2UuUGVlckgAQgcKBWV2ZW50Ih0KD1B1YlN1Yk1lc3NhZ2VJRBIKCgJpZBgBIAIoDCJJCg1QdWJTdWJNZXNzYWdlEhoKBGRhdGEYASACKAsyDC5icmlkZ2UuRGF0YRIcCgV0b3BpYxgCIAIoCzINLmJyaWRnZS5Ub3BpYyKoAQoRUHViU3ViUmVjdk1lc3NhZ2USKAoScHJvcGFnYXRpb25fc291cmNlGAEgAigLMgwuYnJpZGdlLlBlZXISHAoGc291cmNlGAIgASgLMgwuYnJpZGdlLlBlZXISIgoDbXNnGAMgAigLMhUuYnJpZGdlLlB1YlN1Yk1lc3NhZ2USJwoGbXNnX2lkGAQgAigLMhcuYnJpZGdlLlB1YlN1Yk1lc3NhZ2VJRCIzCgZESFRLZXkSHAoFdG9waWMYASACKAsyDS5icmlkZ2UuVG9waWMSCwoDa2V5GAIgAigMIkUKCURIVFJlY29yZBIbCgNrZXkYASACKAsyDi5icmlkZ2UuREhUS2V5EhsKBXZhbHVlGAIgAigLMgwuYnJpZGdlLkRhdGEiNAoIREJSZWNvcmQSCwoDa2V5GAEgAigJEhsKBXZhbHVlGAIgAigLMgwuYnJpZGdlLkRhdGEiFAoFREJLZXkSCwoDa2V5GAEgAigJIhgKCEZpbGVQYXRoEgwKBHBhdGgYASACKAkiKwoDQ0lEEgwKBGhhc2gYASACKAwSFgoCaWQYAiACKAsyCi5icmlkZ2UuSUQiTwoNRG93bmxvYWRFdmVudBISCghwcm9ncmVzcxgBIAEoBEgAEiEKBXJlYWR5GAIgASgLMhAuYnJpZGdlLkZpbGVQYXRoSABCBwoFZXZlbnQiVgoRTWVzaFRvcG9sb2d5RXZlbnQSGgoEcGVlchgBIAIoCzIMLmJyaWRnZS5QZWVyEiUKBWV2ZW50GAIgAigLMhYuYnJpZGdlLk5laWdoYm91ckV2ZW50ImkKEVJlcXVlc3REZWJ1Z0V2ZW50EhYKAmlkGAEgAigLMgouYnJpZGdlLklEEh4KCHJlY2VpdmVyGAIgAigLMgwuYnJpZGdlLlBlZXISHAoDbXNnGAMgAigLMg8uYnJpZGdlLk1lc3NhZ2UiVAoSUmVzcG9uc2VEZWJ1Z0V2ZW50EhoKBnJlcV9pZBgBIAIoCzIKLmJyaWRnZS5JRBIiCghyZXNwb25zZRgCIAIoCzIQLmJyaWRnZS5SZXNwb25zZSK5AQoRTWVzc2FnZURlYnVnRXZlbnQSHAoGc2VuZGVyGAEgAigLMgwuYnJpZGdlLlBlZXISKAoDcmVxGAIgASgLMhkuYnJpZGdlLlJlcXVlc3REZWJ1Z0V2ZW50SAASKQoDcmVzGAMgASgLMhouYnJpZGdlLlJlc3BvbnNlRGVidWdFdmVudEgAEigKB3B1Yl9zdWIYBCABKAsyFS5icmlkZ2UuUHViU3ViTWVzc2FnZUgAQgcKBWV2ZW50IhsKC0RvY2tlckltYWdlEgwKBG5hbWUYASACKAkiPgoJRG9ja2VyQXBwEiIKBWltYWdlGAEgAigLMhMuYnJpZGdlLkRvY2tlckltYWdlEg0KBXBvcnRzGAIgAygNInEKEERlcGxveUFwcFJlcXVlc3QSHgoDYXBwGAEgAigLMhEuYnJpZGdlLkRvY2tlckFwcBINCgVsb2NhbBgCIAIoCBIaCgRwZWVyGAMgASgLMgwuYnJpZGdlLlBlZXISEgoKcGVyc2lzdGVudBgEIAIoCCI0ChZMaXN0UnVubmluZ0FwcHNSZXF1ZXN0EhoKBHBlZXIYASABKAsyDC5icmlkZ2UuUGVlciJWCgpSdW5uaW5nQXBwEhYKAmlkGAEgAigLMgouYnJpZGdlLklEEiIKBWltYWdlGAIgAigLMhMuYnJpZGdlLkRvY2tlckltYWdlEgwKBG5hbWUYAyABKAkiLwoLUnVubmluZ0FwcHMSIAoEYXBwcxgBIAMoCzISLmJyaWRnZS5SdW5uaW5nQXBwIkQKDlN0b3BBcHBSZXF1ZXN0EhYKAmlkGAEgAigLMgouYnJpZGdlLklEEhoKBHBlZXIYAiABKAsyDC5icmlkZ2UuUGVlcjKpAQoHUmVxUmVzcBIvCgRTZW5kEhMuYnJpZGdlLlNlbmRSZXF1ZXN0GhAuYnJpZGdlLlJlc3BvbnNlIgASOwoEUmVjdhIaLmJyaWRnZS5PcHRpb25hbFRvcGljUXVlcnkaEy5icmlkZ2UuUmVjdlJlcXVlc3QiADABEjAKB1Jlc3BvbmQSFC5icmlkZ2UuU2VuZFJlc3BvbnNlGg0uYnJpZGdlLkVtcHR5IgAySgoKTmVpZ2hib3VycxI8Cg9TdWJzY3JpYmVFdmVudHMSDS5icmlkZ2UuRW1wdHkaFi5icmlkZ2UuTmVpZ2hib3VyRXZlbnQiADABMoABCgZQdWJTdWISOQoJU3Vic2NyaWJlEg0uYnJpZGdlLlRvcGljGhkuYnJpZGdlLlB1YlN1YlJlY3ZNZXNzYWdlIgAwARI7CgdQdWJsaXNoEhUuYnJpZGdlLlB1YlN1Yk1lc3NhZ2UaFy5icmlkZ2UuUHViU3ViTWVzc2FnZUlEIgAymwEKAktWEi8KCVB1dFJlY29yZBIRLmJyaWRnZS5ESFRSZWNvcmQaDS5icmlkZ2UuRW1wdHkiABIzCglHZXRSZWNvcmQSDi5icmlkZ2UuREhUS2V5GhQuYnJpZGdlLk9wdGlvbmFsRGF0YSIAEi8KDFJlbW92ZVJlY29yZBIOLmJyaWRnZS5ESFRLZXkaDS5icmlkZ2UuRW1wdHkiADLGAQoJRGlzY292ZXJ5EioKB1Byb3ZpZGUSDi5icmlkZ2UuREhUS2V5Gg0uYnJpZGdlLkVtcHR5IgASMAoMR2V0UHJvdmlkZXJzEg4uYnJpZGdlLkRIVEtleRoMLmJyaWRnZS5QZWVyIgAwARIwCg1TdG9wUHJvdmlkaW5nEg4uYnJpZGdlLkRIVEtleRoNLmJyaWRnZS5FbXB0eSIAEikKCEdldE93bklkEg0uYnJpZGdlLkVtcHR5GgwuYnJpZGdlLlBlZXIiADJoCgdMb2NhbEtWEi8KA1B1dBIQLmJyaWRnZS5EQlJlY29yZBoULmJyaWRnZS5PcHRpb25hbERhdGEiABIsCgNHZXQSDS5icmlkZ2UuREJLZXkaFC5icmlkZ2UuT3B0aW9uYWxEYXRhIgAyqQEKDEZpbGVUcmFuc2ZlchIuCgtQdWJsaXNoRmlsZRIQLmJyaWRnZS5GaWxlUGF0aBoLLmJyaWRnZS5DSUQiABIqCgdHZXRGaWxlEgsuYnJpZGdlLkNJRBoQLmJyaWRnZS5GaWxlUGF0aCIAEj0KE0dldEZpbGVXaXRoUHJvZ3Jlc3MSCy5icmlkZ2UuQ0lEGhUuYnJpZGdlLkRvd25sb2FkRXZlbnQiADABMpEBCgVEZWJ1ZxJFChVTdWJzY3JpYmVNZXNoVG9wb2xvZ3kSDS5icmlkZ2UuRW1wdHkaGS5icmlkZ2UuTWVzaFRvcG9sb2d5RXZlbnQiADABEkEKEVN1YnNjcmliZU1lc3NhZ2VzEg0uYnJpZGdlLkVtcHR5GhkuYnJpZGdlLk1lc3NhZ2VEZWJ1Z0V2ZW50IgAwATLlAQoEQXBwcxIzCglEZXBsb3lBcHASGC5icmlkZ2UuRGVwbG95QXBwUmVxdWVzdBoKLmJyaWRnZS5JRCIAEkgKD0xpc3RSdW5uaW5nQXBwcxIeLmJyaWRnZS5MaXN0UnVubmluZ0FwcHNSZXF1ZXN0GhMuYnJpZGdlLlJ1bm5pbmdBcHBzIgASMgoHU3RvcEFwcBIWLmJyaWRnZS5TdG9wQXBwUmVxdWVzdBoNLmJyaWRnZS5FbXB0eSIAEioKC0dldE93bkFwcElkEg0uYnJpZGdlLkVtcHR5GgouYnJpZGdlLklEIgA");

/**
 * @generated from message bridge.Empty
 */
export type Empty = Message$1<"bridge.Empty"> & {
};

/**
 * Describes the message bridge.Empty.
 * Use `create(EmptySchema)` to create a new message.
 */
export const EmptySchema: GenMessage<Empty> = /*@__PURE__*/
  messageDesc(file_bridge, 0);

/**
 * @generated from message bridge.Data
 */
export type Data = Message$1<"bridge.Data"> & {
  /**
   * @generated from field: required bytes data = 1;
   */
  data: Uint8Array;
};

/**
 * Describes the message bridge.Data.
 * Use `create(DataSchema)` to create a new message.
 */
export const DataSchema: GenMessage<Data> = /*@__PURE__*/
  messageDesc(file_bridge, 1);

/**
 * @generated from message bridge.OptionalData
 */
export type OptionalData = Message$1<"bridge.OptionalData"> & {
  /**
   * @generated from field: optional bridge.Data data = 1;
   */
  data?: Data;
};

/**
 * Describes the message bridge.OptionalData.
 * Use `create(OptionalDataSchema)` to create a new message.
 */
export const OptionalDataSchema: GenMessage<OptionalData> = /*@__PURE__*/
  messageDesc(file_bridge, 2);

/**
 * Unique identifier in the form of a stringified ULID
 *
 * @generated from message bridge.ID
 */
export type ID = Message$1<"bridge.ID"> & {
  /**
   * @generated from field: required string ulid = 1;
   */
  ulid: string;
};

/**
 * Describes the message bridge.ID.
 * Use `create(IDSchema)` to create a new message.
 */
export const IDSchema: GenMessage<ID> = /*@__PURE__*/
  messageDesc(file_bridge, 3);

/**
 * A peer in the network
 *
 * @generated from message bridge.Peer
 */
export type Peer = Message$1<"bridge.Peer"> & {
  /**
   * @generated from field: required string peer_id = 1;
   */
  peerId: string;
};

/**
 * Describes the message bridge.Peer.
 * Use `create(PeerSchema)` to create a new message.
 */
export const PeerSchema: GenMessage<Peer> = /*@__PURE__*/
  messageDesc(file_bridge, 4);

/**
 * The topic of a message
 *
 * @generated from message bridge.Topic
 */
export type Topic = Message$1<"bridge.Topic"> & {
  /**
   * @generated from field: required string topic = 1;
   */
  topic: string;
};

/**
 * Describes the message bridge.Topic.
 * Use `create(TopicSchema)` to create a new message.
 */
export const TopicSchema: GenMessage<Topic> = /*@__PURE__*/
  messageDesc(file_bridge, 5);

/**
 * An optional topic for a message
 *
 * @generated from message bridge.OptionalTopic
 */
export type OptionalTopic = Message$1<"bridge.OptionalTopic"> & {
  /**
   * @generated from field: optional bridge.Topic topic = 1;
   */
  topic?: Topic;
};

/**
 * Describes the message bridge.OptionalTopic.
 * Use `create(OptionalTopicSchema)` to create a new message.
 */
export const OptionalTopicSchema: GenMessage<OptionalTopic> = /*@__PURE__*/
  messageDesc(file_bridge, 6);

/**
 * A query for a topic that can be a regex
 *
 * @generated from message bridge.TopicQuery
 */
export type TopicQuery = Message$1<"bridge.TopicQuery"> & {
  /**
   * @generated from oneof bridge.TopicQuery.query
   */
  query: {
    /**
     * @generated from field: bridge.Topic topic = 1;
     */
    value: Topic;
    case: "topic";
  } | {
    /**
     * @generated from field: string regex = 2;
     */
    value: string;
    case: "regex";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.TopicQuery.
 * Use `create(TopicQuerySchema)` to create a new message.
 */
export const TopicQuerySchema: GenMessage<TopicQuery> = /*@__PURE__*/
  messageDesc(file_bridge, 7);

/**
 * An optional query for a topic
 *
 * @generated from message bridge.OptionalTopicQuery
 */
export type OptionalTopicQuery = Message$1<"bridge.OptionalTopicQuery"> & {
  /**
   * @generated from field: optional bridge.TopicQuery query = 1;
   */
  query?: TopicQuery;
};

/**
 * Describes the message bridge.OptionalTopicQuery.
 * Use `create(OptionalTopicQuerySchema)` to create a new message.
 */
export const OptionalTopicQuerySchema: GenMessage<OptionalTopicQuery> = /*@__PURE__*/
  messageDesc(file_bridge, 8);

/**
 * A message with an optional topic
 *
 * @generated from message bridge.Message
 */
export type Message = Message$1<"bridge.Message"> & {
  /**
   * @generated from field: required bridge.Data data = 1;
   */
  data?: Data;

  /**
   * @generated from field: required bridge.OptionalTopic topic = 2;
   */
  topic?: OptionalTopic;
};

/**
 * Describes the message bridge.Message.
 * Use `create(MessageSchema)` to create a new message.
 */
export const MessageSchema: GenMessage<Message> = /*@__PURE__*/
  messageDesc(file_bridge, 9);

/**
 * A request to a peer with an optional topic
 *
 * @generated from message bridge.SendRequest
 */
export type SendRequest = Message$1<"bridge.SendRequest"> & {
  /**
   * @generated from field: required bridge.Peer peer = 1;
   */
  peer?: Peer;

  /**
   * @generated from field: required bridge.Message msg = 2;
   */
  msg?: Message;
};

/**
 * Describes the message bridge.SendRequest.
 * Use `create(SendRequestSchema)` to create a new message.
 */
export const SendRequestSchema: GenMessage<SendRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 10);

/**
 * A request from a peer with an optional topic
 *
 * @generated from message bridge.RecvRequest
 */
export type RecvRequest = Message$1<"bridge.RecvRequest"> & {
  /**
   * @generated from field: required bridge.Peer peer = 1;
   */
  peer?: Peer;

  /**
   * @generated from field: required bridge.Message msg = 2;
   */
  msg?: Message;

  /**
   * Sequence number for request-response matching
   *
   * @generated from field: required uint64 seq = 3;
   */
  seq: bigint;
};

/**
 * Describes the message bridge.RecvRequest.
 * Use `create(RecvRequestSchema)` to create a new message.
 */
export const RecvRequestSchema: GenMessage<RecvRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 11);

/**
 * A received response to a request or an error
 *
 * @generated from message bridge.Response
 */
export type Response = Message$1<"bridge.Response"> & {
  /**
   * @generated from oneof bridge.Response.response
   */
  response: {
    /**
     * @generated from field: bridge.Data data = 1;
     */
    value: Data;
    case: "data";
  } | {
    /**
     * @generated from field: string error = 2;
     */
    value: string;
    case: "error";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export const ResponseSchema: GenMessage<Response> = /*@__PURE__*/
  messageDesc(file_bridge, 12);

/**
 * A response to a request
 *
 * @generated from message bridge.SendResponse
 */
export type SendResponse = Message$1<"bridge.SendResponse"> & {
  /**
   * Sequence number for request-response matching
   *
   * @generated from field: required uint64 seq = 1;
   */
  seq: bigint;

  /**
   * @generated from field: required bridge.Response response = 2;
   */
  response?: Response;
};

/**
 * Describes the message bridge.SendResponse.
 * Use `create(SendResponseSchema)` to create a new message.
 */
export const SendResponseSchema: GenMessage<SendResponse> = /*@__PURE__*/
  messageDesc(file_bridge, 13);

/**
 * A list of peers
 *
 * @generated from message bridge.Peers
 */
export type Peers = Message$1<"bridge.Peers"> & {
  /**
   * @generated from field: repeated bridge.Peer peers = 1;
   */
  peers: Peer[];
};

/**
 * Describes the message bridge.Peers.
 * Use `create(PeersSchema)` to create a new message.
 */
export const PeersSchema: GenMessage<Peers> = /*@__PURE__*/
  messageDesc(file_bridge, 14);

/**
 * A neighbour discovery event
 *
 * @generated from message bridge.NeighbourEvent
 */
export type NeighbourEvent = Message$1<"bridge.NeighbourEvent"> & {
  /**
   * @generated from oneof bridge.NeighbourEvent.event
   */
  event: {
    /**
     * @generated from field: bridge.Peers init = 1;
     */
    value: Peers;
    case: "init";
  } | {
    /**
     * @generated from field: bridge.Peer discovered = 2;
     */
    value: Peer;
    case: "discovered";
  } | {
    /**
     * @generated from field: bridge.Peer lost = 3;
     */
    value: Peer;
    case: "lost";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.NeighbourEvent.
 * Use `create(NeighbourEventSchema)` to create a new message.
 */
export const NeighbourEventSchema: GenMessage<NeighbourEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 15);

/**
 * An ID of a message in pub-sub
 *
 * @generated from message bridge.PubSubMessageID
 */
export type PubSubMessageID = Message$1<"bridge.PubSubMessageID"> & {
  /**
   * @generated from field: required bytes id = 1;
   */
  id: Uint8Array;
};

/**
 * Describes the message bridge.PubSubMessageID.
 * Use `create(PubSubMessageIDSchema)` to create a new message.
 */
export const PubSubMessageIDSchema: GenMessage<PubSubMessageID> = /*@__PURE__*/
  messageDesc(file_bridge, 16);

/**
 * A message for publishing in a pub-sub topic
 *
 * @generated from message bridge.PubSubMessage
 */
export type PubSubMessage = Message$1<"bridge.PubSubMessage"> & {
  /**
   * @generated from field: required bridge.Data data = 1;
   */
  data?: Data;

  /**
   * @generated from field: required bridge.Topic topic = 2;
   */
  topic?: Topic;
};

/**
 * Describes the message bridge.PubSubMessage.
 * Use `create(PubSubMessageSchema)` to create a new message.
 */
export const PubSubMessageSchema: GenMessage<PubSubMessage> = /*@__PURE__*/
  messageDesc(file_bridge, 17);

/**
 * A received message from a pub-sub topic
 *
 * @generated from message bridge.PubSubRecvMessage
 */
export type PubSubRecvMessage = Message$1<"bridge.PubSubRecvMessage"> & {
  /**
   * @generated from field: required bridge.Peer propagation_source = 1;
   */
  propagationSource?: Peer;

  /**
   * @generated from field: optional bridge.Peer source = 2;
   */
  source?: Peer;

  /**
   * @generated from field: required bridge.PubSubMessage msg = 3;
   */
  msg?: PubSubMessage;

  /**
   * @generated from field: required bridge.PubSubMessageID msg_id = 4;
   */
  msgId?: PubSubMessageID;
};

/**
 * Describes the message bridge.PubSubRecvMessage.
 * Use `create(PubSubRecvMessageSchema)` to create a new message.
 */
export const PubSubRecvMessageSchema: GenMessage<PubSubRecvMessage> = /*@__PURE__*/
  messageDesc(file_bridge, 18);

/**
 * A DHT key with a topic
 *
 * @generated from message bridge.DHTKey
 */
export type DHTKey = Message$1<"bridge.DHTKey"> & {
  /**
   * @generated from field: required bridge.Topic topic = 1;
   */
  topic?: Topic;

  /**
   * @generated from field: required bytes key = 2;
   */
  key: Uint8Array;
};

/**
 * Describes the message bridge.DHTKey.
 * Use `create(DHTKeySchema)` to create a new message.
 */
export const DHTKeySchema: GenMessage<DHTKey> = /*@__PURE__*/
  messageDesc(file_bridge, 19);

/**
 * A record for putting in the DHT
 *
 * @generated from message bridge.DHTRecord
 */
export type DHTRecord = Message$1<"bridge.DHTRecord"> & {
  /**
   * @generated from field: required bridge.DHTKey key = 1;
   */
  key?: DHTKey;

  /**
   * @generated from field: required bridge.Data value = 2;
   */
  value?: Data;
};

/**
 * Describes the message bridge.DHTRecord.
 * Use `create(DHTRecordSchema)` to create a new message.
 */
export const DHTRecordSchema: GenMessage<DHTRecord> = /*@__PURE__*/
  messageDesc(file_bridge, 20);

/**
 * A key-value pair for putting in the database
 *
 * @generated from message bridge.DBRecord
 */
export type DBRecord = Message$1<"bridge.DBRecord"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: required bridge.Data value = 2;
   */
  value?: Data;
};

/**
 * Describes the message bridge.DBRecord.
 * Use `create(DBRecordSchema)` to create a new message.
 */
export const DBRecordSchema: GenMessage<DBRecord> = /*@__PURE__*/
  messageDesc(file_bridge, 21);

/**
 * A key for getting a value from the database
 *
 * @generated from message bridge.DBKey
 */
export type DBKey = Message$1<"bridge.DBKey"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;
};

/**
 * Describes the message bridge.DBKey.
 * Use `create(DBKeySchema)` to create a new message.
 */
export const DBKeySchema: GenMessage<DBKey> = /*@__PURE__*/
  messageDesc(file_bridge, 22);

/**
 * A file path on the local filesystem
 *
 * @generated from message bridge.FilePath
 */
export type FilePath = Message$1<"bridge.FilePath"> & {
  /**
   * @generated from field: required string path = 1;
   */
  path: string;
};

/**
 * Describes the message bridge.FilePath.
 * Use `create(FilePathSchema)` to create a new message.
 */
export const FilePathSchema: GenMessage<FilePath> = /*@__PURE__*/
  messageDesc(file_bridge, 23);

/**
 * The cid of a file
 *
 * @generated from message bridge.CID
 */
export type CID = Message$1<"bridge.CID"> & {
  /**
   * @generated from field: required bytes hash = 1;
   */
  hash: Uint8Array;

  /**
   * @generated from field: required bridge.ID id = 2;
   */
  id?: ID;
};

/**
 * Describes the message bridge.CID.
 * Use `create(CIDSchema)` to create a new message.
 */
export const CIDSchema: GenMessage<CID> = /*@__PURE__*/
  messageDesc(file_bridge, 24);

/**
 * A download event
 *
 * The progress field is a percentage of the download progress
 *
 * @generated from message bridge.DownloadEvent
 */
export type DownloadEvent = Message$1<"bridge.DownloadEvent"> & {
  /**
   * @generated from oneof bridge.DownloadEvent.event
   */
  event: {
    /**
     * @generated from field: uint64 progress = 1;
     */
    value: bigint;
    case: "progress";
  } | {
    /**
     * @generated from field: bridge.FilePath ready = 2;
     */
    value: FilePath;
    case: "ready";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.DownloadEvent.
 * Use `create(DownloadEventSchema)` to create a new message.
 */
export const DownloadEventSchema: GenMessage<DownloadEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 25);

/**
 * A mesh topology event
 *
 * @generated from message bridge.MeshTopologyEvent
 */
export type MeshTopologyEvent = Message$1<"bridge.MeshTopologyEvent"> & {
  /**
   * @generated from field: required bridge.Peer peer = 1;
   */
  peer?: Peer;

  /**
   * @generated from field: required bridge.NeighbourEvent event = 2;
   */
  event?: NeighbourEvent;
};

/**
 * Describes the message bridge.MeshTopologyEvent.
 * Use `create(MeshTopologyEventSchema)` to create a new message.
 */
export const MeshTopologyEventSchema: GenMessage<MeshTopologyEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 26);

/**
 * A request debug event
 *
 * @generated from message bridge.RequestDebugEvent
 */
export type RequestDebugEvent = Message$1<"bridge.RequestDebugEvent"> & {
  /**
   * @generated from field: required bridge.ID id = 1;
   */
  id?: ID;

  /**
   * @generated from field: required bridge.Peer receiver = 2;
   */
  receiver?: Peer;

  /**
   * @generated from field: required bridge.Message msg = 3;
   */
  msg?: Message;
};

/**
 * Describes the message bridge.RequestDebugEvent.
 * Use `create(RequestDebugEventSchema)` to create a new message.
 */
export const RequestDebugEventSchema: GenMessage<RequestDebugEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 27);

/**
 * A response debug event
 *
 * @generated from message bridge.ResponseDebugEvent
 */
export type ResponseDebugEvent = Message$1<"bridge.ResponseDebugEvent"> & {
  /**
   * @generated from field: required bridge.ID req_id = 1;
   */
  reqId?: ID;

  /**
   * @generated from field: required bridge.Response response = 2;
   */
  response?: Response;
};

/**
 * Describes the message bridge.ResponseDebugEvent.
 * Use `create(ResponseDebugEventSchema)` to create a new message.
 */
export const ResponseDebugEventSchema: GenMessage<ResponseDebugEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 28);

/**
 * A message debug event
 *
 * @generated from message bridge.MessageDebugEvent
 */
export type MessageDebugEvent = Message$1<"bridge.MessageDebugEvent"> & {
  /**
   * @generated from field: required bridge.Peer sender = 1;
   */
  sender?: Peer;

  /**
   * @generated from oneof bridge.MessageDebugEvent.event
   */
  event: {
    /**
     * @generated from field: bridge.RequestDebugEvent req = 2;
     */
    value: RequestDebugEvent;
    case: "req";
  } | {
    /**
     * @generated from field: bridge.ResponseDebugEvent res = 3;
     */
    value: ResponseDebugEvent;
    case: "res";
  } | {
    /**
     * @generated from field: bridge.PubSubMessage pub_sub = 4;
     */
    value: PubSubMessage;
    case: "pubSub";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.MessageDebugEvent.
 * Use `create(MessageDebugEventSchema)` to create a new message.
 */
export const MessageDebugEventSchema: GenMessage<MessageDebugEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 29);

/**
 * A docker image
 *
 * @generated from message bridge.DockerImage
 */
export type DockerImage = Message$1<"bridge.DockerImage"> & {
  /**
   * @generated from field: required string name = 1;
   */
  name: string;
};

/**
 * Describes the message bridge.DockerImage.
 * Use `create(DockerImageSchema)` to create a new message.
 */
export const DockerImageSchema: GenMessage<DockerImage> = /*@__PURE__*/
  messageDesc(file_bridge, 30);

/**
 * A docker app
 *
 * @generated from message bridge.DockerApp
 */
export type DockerApp = Message$1<"bridge.DockerApp"> & {
  /**
   * @generated from field: required bridge.DockerImage image = 1;
   */
  image?: DockerImage;

  /**
   * @generated from field: repeated uint32 ports = 2;
   */
  ports: number[];
};

/**
 * Describes the message bridge.DockerApp.
 * Use `create(DockerAppSchema)` to create a new message.
 */
export const DockerAppSchema: GenMessage<DockerApp> = /*@__PURE__*/
  messageDesc(file_bridge, 31);

/**
 * A request to deploy an app to a peer
 *
 * @generated from message bridge.DeployAppRequest
 */
export type DeployAppRequest = Message$1<"bridge.DeployAppRequest"> & {
  /**
   * @generated from field: required bridge.DockerApp app = 1;
   */
  app?: DockerApp;

  /**
   * @generated from field: required bool local = 2;
   */
  local: boolean;

  /**
   * The peer can be empty if the app should be deployed to self
   *
   * @generated from field: optional bridge.Peer peer = 3;
   */
  peer?: Peer;

  /**
   * @generated from field: required bool persistent = 4;
   */
  persistent: boolean;
};

/**
 * Describes the message bridge.DeployAppRequest.
 * Use `create(DeployAppRequestSchema)` to create a new message.
 */
export const DeployAppRequestSchema: GenMessage<DeployAppRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 32);

/**
 * A request to list running apps on a peer
 *
 * @generated from message bridge.ListRunningAppsRequest
 */
export type ListRunningAppsRequest = Message$1<"bridge.ListRunningAppsRequest"> & {
  /**
   * The peer can be empty if the apps running on self should be listed
   *
   * @generated from field: optional bridge.Peer peer = 1;
   */
  peer?: Peer;
};

/**
 * Describes the message bridge.ListRunningAppsRequest.
 * Use `create(ListRunningAppsRequestSchema)` to create a new message.
 */
export const ListRunningAppsRequestSchema: GenMessage<ListRunningAppsRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 33);

/**
 * An app that is running on a peer
 *
 * @generated from message bridge.RunningApp
 */
export type RunningApp = Message$1<"bridge.RunningApp"> & {
  /**
   * @generated from field: required bridge.ID id = 1;
   */
  id?: ID;

  /**
   * @generated from field: required bridge.DockerImage image = 2;
   */
  image?: DockerImage;

  /**
   * @generated from field: optional string name = 3;
   */
  name: string;
};

/**
 * Describes the message bridge.RunningApp.
 * Use `create(RunningAppSchema)` to create a new message.
 */
export const RunningAppSchema: GenMessage<RunningApp> = /*@__PURE__*/
  messageDesc(file_bridge, 34);

/**
 * A list of running apps
 *
 * @generated from message bridge.RunningApps
 */
export type RunningApps = Message$1<"bridge.RunningApps"> & {
  /**
   * @generated from field: repeated bridge.RunningApp apps = 1;
   */
  apps: RunningApp[];
};

/**
 * Describes the message bridge.RunningApps.
 * Use `create(RunningAppsSchema)` to create a new message.
 */
export const RunningAppsSchema: GenMessage<RunningApps> = /*@__PURE__*/
  messageDesc(file_bridge, 35);

/**
 * A request to stop a running app on a peer
 *
 * @generated from message bridge.StopAppRequest
 */
export type StopAppRequest = Message$1<"bridge.StopAppRequest"> & {
  /**
   * @generated from field: required bridge.ID id = 1;
   */
  id?: ID;

  /**
   * The peer can be empty if the app should be stopped on self
   *
   * @generated from field: optional bridge.Peer peer = 2;
   */
  peer?: Peer;
};

/**
 * Describes the message bridge.StopAppRequest.
 * Use `create(StopAppRequestSchema)` to create a new message.
 */
export const StopAppRequestSchema: GenMessage<StopAppRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 36);

/**
 * @generated from service bridge.ReqResp
 */
export const ReqResp: GenService<{
  /**
   * Send a request with an optional topic to a peer and wait for a response
   *
   * @generated from rpc bridge.ReqResp.Send
   */
  send: {
    methodKind: "unary";
    input: typeof SendRequestSchema;
    output: typeof ResponseSchema;
  },
  /**
   * Receive requests from peers that either have no topic or have a topic that
   * has been subscribed to
   *
   * @generated from rpc bridge.ReqResp.Recv
   */
  recv: {
    methodKind: "server_streaming";
    input: typeof OptionalTopicQuerySchema;
    output: typeof RecvRequestSchema;
  },
  /**
   * Respond to a request received from Recv
   *
   * @generated from rpc bridge.ReqResp.Respond
   */
  respond: {
    methodKind: "unary";
    input: typeof SendResponseSchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 0);

/**
 * @generated from service bridge.Neighbours
 */
export const Neighbours: GenService<{
  /**
   * Subscribe to neighbour discovery events to get notified when new neighbour
   * peers are discovered or lost
   *
   * @generated from rpc bridge.Neighbours.SubscribeEvents
   */
  subscribeEvents: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof NeighbourEventSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 1);

/**
 * @generated from service bridge.PubSub
 */
export const PubSub: GenService<{
  /**
   * Subscribe to a pub-sub topic to receive messages published in that topic
   *
   * @generated from rpc bridge.PubSub.Subscribe
   */
  subscribe: {
    methodKind: "server_streaming";
    input: typeof TopicSchema;
    output: typeof PubSubRecvMessageSchema;
  },
  /**
   * Publish a message in a pub-sub topic
   *
   * @generated from rpc bridge.PubSub.Publish
   */
  publish: {
    methodKind: "unary";
    input: typeof PubSubMessageSchema;
    output: typeof PubSubMessageIDSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 2);

/**
 * @generated from service bridge.KV
 */
export const KV: GenService<{
  /**
   * Put a record into the global key-value store
   *
   * @generated from rpc bridge.KV.PutRecord
   */
  putRecord: {
    methodKind: "unary";
    input: typeof DHTRecordSchema;
    output: typeof EmptySchema;
  },
  /**
   * Get a record from the global key-value store.
   * The value of the record will be empty if the key is not found.
   *
   * @generated from rpc bridge.KV.GetRecord
   */
  getRecord: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof OptionalDataSchema;
  },
  /**
   * Remove a record from the global key-value store.
   * This only has local effects and only affects the key-value store once the
   * records expire.
   *
   * @generated from rpc bridge.KV.RemoveRecord
   */
  removeRecord: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 3);

/**
 * @generated from service bridge.Discovery
 */
export const Discovery: GenService<{
  /**
   * Mark the current runtime as a provider for a discovery key
   *
   * @generated from rpc bridge.Discovery.Provide
   */
  provide: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof EmptySchema;
  },
  /**
   * Get the providers of a discovery key
   *
   * @generated from rpc bridge.Discovery.GetProviders
   */
  getProviders: {
    methodKind: "server_streaming";
    input: typeof DHTKeySchema;
    output: typeof PeerSchema;
  },
  /**
   * Stop providing a discovery key.
   * This only has local effects and only affects other hyveOS nodes once the
   * providers records expire.
   *
   * @generated from rpc bridge.Discovery.StopProviding
   */
  stopProviding: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof EmptySchema;
  },
  /**
   * Get the peer id of the current runtime
   *
   * @generated from rpc bridge.Discovery.GetOwnId
   */
  getOwnId: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof PeerSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 4);

/**
 * @generated from service bridge.LocalKV
 */
export const LocalKV: GenService<{
  /**
   * Put a record into the local key-value store and get the previous value if
   * it exists. This only has local effects but will be persisted across
   * restarts.
   *
   * @generated from rpc bridge.LocalKV.Put
   */
  put: {
    methodKind: "unary";
    input: typeof DBRecordSchema;
    output: typeof OptionalDataSchema;
  },
  /**
   * Get a record from the local key-value store.
   * This will not return records from other hyveOS nodes.
   *
   * @generated from rpc bridge.LocalKV.Get
   */
  get: {
    methodKind: "unary";
    input: typeof DBKeySchema;
    output: typeof OptionalDataSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 5);

/**
 * @generated from service bridge.FileTransfer
 */
export const FileTransfer: GenService<{
  /**
   * Publish a file in the runtime and get the cid of the file
   *
   * @generated from rpc bridge.FileTransfer.PublishFile
   */
  publishFile: {
    methodKind: "unary";
    input: typeof FilePathSchema;
    output: typeof CIDSchema;
  },
  /**
   * Request a file with a cid from the runtime
   *
   * @generated from rpc bridge.FileTransfer.GetFile
   */
  getFile: {
    methodKind: "unary";
    input: typeof CIDSchema;
    output: typeof FilePathSchema;
  },
  /**
   * Request a file with a cid from the runtime and get notified about the
   * download progress
   *
   * @generated from rpc bridge.FileTransfer.GetFileWithProgress
   */
  getFileWithProgress: {
    methodKind: "server_streaming";
    input: typeof CIDSchema;
    output: typeof DownloadEventSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 6);

/**
 * @generated from service bridge.Debug
 */
export const Debug: GenService<{
  /**
   * Subscribe to mesh topology events to get notified when the mesh topology
   * changes
   *
   * @generated from rpc bridge.Debug.SubscribeMeshTopology
   */
  subscribeMeshTopology: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof MeshTopologyEventSchema;
  },
  /**
   * Subscribe to message debug events to get notified when messages are sent
   *
   * @generated from rpc bridge.Debug.SubscribeMessages
   */
  subscribeMessages: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof MessageDebugEventSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 7);

/**
 * @generated from service bridge.Apps
 */
export const Apps: GenService<{
  /**
   * Deploy an app to a peer and get the id of the deployed app
   *
   * @generated from rpc bridge.Apps.DeployApp
   */
  deployApp: {
    methodKind: "unary";
    input: typeof DeployAppRequestSchema;
    output: typeof IDSchema;
  },
  /**
   * List running apps on a peer
   *
   * @generated from rpc bridge.Apps.ListRunningApps
   */
  listRunningApps: {
    methodKind: "unary";
    input: typeof ListRunningAppsRequestSchema;
    output: typeof RunningAppsSchema;
  },
  /**
   * Stop a running app on a peer
   *
   * @generated from rpc bridge.Apps.StopApp
   */
  stopApp: {
    methodKind: "unary";
    input: typeof StopAppRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Get the id of the current app
   *
   * @generated from rpc bridge.Apps.GetOwnAppId
   */
  getOwnAppId: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof IDSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 8);

