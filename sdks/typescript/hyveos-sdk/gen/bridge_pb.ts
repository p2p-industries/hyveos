// Put the basic example for grpc using proto2 here

// @generated by protoc-gen-es v2.2.3 with parameter "target=ts"
// @generated from file bridge.proto (package bridge, syntax proto2)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { Message as Message$1 } from "@bufbuild/protobuf";

/**
 * Describes the file bridge.proto.
 */
export const file_bridge: GenFile = /*@__PURE__*/
  fileDesc("CgxicmlkZ2UucHJvdG8SBmJyaWRnZSIHCgVFbXB0eSIUCgREYXRhEgwKBGRhdGEYASACKAwiKgoMT3B0aW9uYWxEYXRhEhoKBGRhdGEYASABKAsyDC5icmlkZ2UuRGF0YSISCgJJRBIMCgR1bGlkGAEgAigJIhcKBFBlZXISDwoHcGVlcl9pZBgBIAIoCSIWCgVUb3BpYxINCgV0b3BpYxgBIAIoCSItCg1PcHRpb25hbFRvcGljEhwKBXRvcGljGAEgASgLMg0uYnJpZGdlLlRvcGljIkYKClRvcGljUXVlcnkSHgoFdG9waWMYASABKAsyDS5icmlkZ2UuVG9waWNIABIPCgVyZWdleBgCIAEoCUgAQgcKBXF1ZXJ5IjcKEk9wdGlvbmFsVG9waWNRdWVyeRIhCgVxdWVyeRgBIAEoCzISLmJyaWRnZS5Ub3BpY1F1ZXJ5IksKB01lc3NhZ2USGgoEZGF0YRgBIAIoCzIMLmJyaWRnZS5EYXRhEiQKBXRvcGljGAIgAigLMhUuYnJpZGdlLk9wdGlvbmFsVG9waWMiRwoLU2VuZFJlcXVlc3QSGgoEcGVlchgBIAIoCzIMLmJyaWRnZS5QZWVyEhwKA21zZxgCIAIoCzIPLmJyaWRnZS5NZXNzYWdlIlQKC1JlY3ZSZXF1ZXN0EhoKBHBlZXIYASACKAsyDC5icmlkZ2UuUGVlchIcCgNtc2cYAiACKAsyDy5icmlkZ2UuTWVzc2FnZRILCgNzZXEYAyACKAQiRQoIUmVzcG9uc2USHAoEZGF0YRgBIAEoCzIMLmJyaWRnZS5EYXRhSAASDwoFZXJyb3IYAiABKAlIAEIKCghyZXNwb25zZSI/CgxTZW5kUmVzcG9uc2USCwoDc2VxGAEgAigEEiIKCHJlc3BvbnNlGAIgAigLMhAuYnJpZGdlLlJlc3BvbnNlIiQKBVBlZXJzEhsKBXBlZXJzGAEgAygLMgwuYnJpZGdlLlBlZXIiegoOTmVpZ2hib3VyRXZlbnQSHQoEaW5pdBgBIAEoCzINLmJyaWRnZS5QZWVyc0gAEiIKCmRpc2NvdmVyZWQYAiABKAsyDC5icmlkZ2UuUGVlckgAEhwKBGxvc3QYAyABKAsyDC5icmlkZ2UuUGVlckgAQgcKBWV2ZW50Ih0KD1B1YlN1Yk1lc3NhZ2VJRBIKCgJpZBgBIAIoDCJJCg1QdWJTdWJNZXNzYWdlEhoKBGRhdGEYASACKAsyDC5icmlkZ2UuRGF0YRIcCgV0b3BpYxgCIAIoCzINLmJyaWRnZS5Ub3BpYyKoAQoRUHViU3ViUmVjdk1lc3NhZ2USKAoScHJvcGFnYXRpb25fc291cmNlGAEgAigLMgwuYnJpZGdlLlBlZXISHAoGc291cmNlGAIgASgLMgwuYnJpZGdlLlBlZXISIgoDbXNnGAMgAigLMhUuYnJpZGdlLlB1YlN1Yk1lc3NhZ2USJwoGbXNnX2lkGAQgAigLMhcuYnJpZGdlLlB1YlN1Yk1lc3NhZ2VJRCIzCgZESFRLZXkSHAoFdG9waWMYASACKAsyDS5icmlkZ2UuVG9waWMSCwoDa2V5GAIgAigMIkUKCURIVFJlY29yZBIbCgNrZXkYASACKAsyDi5icmlkZ2UuREhUS2V5EhsKBXZhbHVlGAIgAigLMgwuYnJpZGdlLkRhdGEiOQoNTG9jYWxLVlJlY29yZBILCgNrZXkYASACKAkSGwoFdmFsdWUYAiACKAsyDC5icmlkZ2UuRGF0YSIZCgpMb2NhbEtWS2V5EgsKA2tleRgBIAIoCSIYCghGaWxlUGF0aBIMCgRwYXRoGAEgAigJIisKA0NJRBIMCgRoYXNoGAEgAigMEhYKAmlkGAIgAigLMgouYnJpZGdlLklEIk8KDURvd25sb2FkRXZlbnQSEgoIcHJvZ3Jlc3MYASABKARIABIhCgVyZWFkeRgCIAEoCzIQLmJyaWRnZS5GaWxlUGF0aEgAQgcKBWV2ZW50IlYKEU1lc2hUb3BvbG9neUV2ZW50EhoKBHBlZXIYASACKAsyDC5icmlkZ2UuUGVlchIlCgVldmVudBgCIAIoCzIWLmJyaWRnZS5OZWlnaGJvdXJFdmVudCJpChFSZXF1ZXN0RGVidWdFdmVudBIWCgJpZBgBIAIoCzIKLmJyaWRnZS5JRBIeCghyZWNlaXZlchgCIAIoCzIMLmJyaWRnZS5QZWVyEhwKA21zZxgDIAIoCzIPLmJyaWRnZS5NZXNzYWdlIlQKElJlc3BvbnNlRGVidWdFdmVudBIaCgZyZXFfaWQYASACKAsyCi5icmlkZ2UuSUQSIgoIcmVzcG9uc2UYAiACKAsyEC5icmlkZ2UuUmVzcG9uc2UiuQEKEU1lc3NhZ2VEZWJ1Z0V2ZW50EhwKBnNlbmRlchgBIAIoCzIMLmJyaWRnZS5QZWVyEigKA3JlcRgCIAEoCzIZLmJyaWRnZS5SZXF1ZXN0RGVidWdFdmVudEgAEikKA3JlcxgDIAEoCzIaLmJyaWRnZS5SZXNwb25zZURlYnVnRXZlbnRIABIoCgdwdWJfc3ViGAQgASgLMhUuYnJpZGdlLlB1YlN1Yk1lc3NhZ2VIAEIHCgVldmVudCIbCgtEb2NrZXJJbWFnZRIMCgRuYW1lGAEgAigJIj4KCURvY2tlckFwcBIiCgVpbWFnZRgBIAIoCzITLmJyaWRnZS5Eb2NrZXJJbWFnZRINCgVwb3J0cxgCIAMoDSJxChBEZXBsb3lBcHBSZXF1ZXN0Eh4KA2FwcBgBIAIoCzIRLmJyaWRnZS5Eb2NrZXJBcHASDQoFbG9jYWwYAiACKAgSGgoEcGVlchgDIAEoCzIMLmJyaWRnZS5QZWVyEhIKCnBlcnNpc3RlbnQYBCACKAgiNAoWTGlzdFJ1bm5pbmdBcHBzUmVxdWVzdBIaCgRwZWVyGAEgASgLMgwuYnJpZGdlLlBlZXIiVgoKUnVubmluZ0FwcBIWCgJpZBgBIAIoCzIKLmJyaWRnZS5JRBIiCgVpbWFnZRgCIAIoCzITLmJyaWRnZS5Eb2NrZXJJbWFnZRIMCgRuYW1lGAMgASgJIi8KC1J1bm5pbmdBcHBzEiAKBGFwcHMYASADKAsyEi5icmlkZ2UuUnVubmluZ0FwcCJECg5TdG9wQXBwUmVxdWVzdBIWCgJpZBgBIAIoCzIKLmJyaWRnZS5JRBIaCgRwZWVyGAIgASgLMgwuYnJpZGdlLlBlZXIyqQEKB1JlcVJlc3ASLwoEU2VuZBITLmJyaWRnZS5TZW5kUmVxdWVzdBoQLmJyaWRnZS5SZXNwb25zZSIAEjsKBFJlY3YSGi5icmlkZ2UuT3B0aW9uYWxUb3BpY1F1ZXJ5GhMuYnJpZGdlLlJlY3ZSZXF1ZXN0IgAwARIwCgdSZXNwb25kEhQuYnJpZGdlLlNlbmRSZXNwb25zZRoNLmJyaWRnZS5FbXB0eSIAMmsKCk5laWdoYm91cnMSNgoJU3Vic2NyaWJlEg0uYnJpZGdlLkVtcHR5GhYuYnJpZGdlLk5laWdoYm91ckV2ZW50IgAwARIlCgNHZXQSDS5icmlkZ2UuRW1wdHkaDS5icmlkZ2UuUGVlcnMiADKAAQoGUHViU3ViEjkKCVN1YnNjcmliZRINLmJyaWRnZS5Ub3BpYxoZLmJyaWRnZS5QdWJTdWJSZWN2TWVzc2FnZSIAMAESOwoHUHVibGlzaBIVLmJyaWRnZS5QdWJTdWJNZXNzYWdlGhcuYnJpZGdlLlB1YlN1Yk1lc3NhZ2VJRCIAMpsBCgJLVhIvCglQdXRSZWNvcmQSES5icmlkZ2UuREhUUmVjb3JkGg0uYnJpZGdlLkVtcHR5IgASMwoJR2V0UmVjb3JkEg4uYnJpZGdlLkRIVEtleRoULmJyaWRnZS5PcHRpb25hbERhdGEiABIvCgxSZW1vdmVSZWNvcmQSDi5icmlkZ2UuREhUS2V5Gg0uYnJpZGdlLkVtcHR5IgAyxgEKCURpc2NvdmVyeRIqCgdQcm92aWRlEg4uYnJpZGdlLkRIVEtleRoNLmJyaWRnZS5FbXB0eSIAEjAKDEdldFByb3ZpZGVycxIOLmJyaWRnZS5ESFRLZXkaDC5icmlkZ2UuUGVlciIAMAESMAoNU3RvcFByb3ZpZGluZxIOLmJyaWRnZS5ESFRLZXkaDS5icmlkZ2UuRW1wdHkiABIpCghHZXRPd25JZBINLmJyaWRnZS5FbXB0eRoMLmJyaWRnZS5QZWVyIgAycgoHTG9jYWxLVhI0CgNQdXQSFS5icmlkZ2UuTG9jYWxLVlJlY29yZBoULmJyaWRnZS5PcHRpb25hbERhdGEiABIxCgNHZXQSEi5icmlkZ2UuTG9jYWxLVktleRoULmJyaWRnZS5PcHRpb25hbERhdGEiADKdAQoMRmlsZVRyYW5zZmVyEioKB1B1Ymxpc2gSEC5icmlkZ2UuRmlsZVBhdGgaCy5icmlkZ2UuQ0lEIgASJgoDR2V0EgsuYnJpZGdlLkNJRBoQLmJyaWRnZS5GaWxlUGF0aCIAEjkKD0dldFdpdGhQcm9ncmVzcxILLmJyaWRnZS5DSUQaFS5icmlkZ2UuRG93bmxvYWRFdmVudCIAMAEykQEKBURlYnVnEkUKFVN1YnNjcmliZU1lc2hUb3BvbG9neRINLmJyaWRnZS5FbXB0eRoZLmJyaWRnZS5NZXNoVG9wb2xvZ3lFdmVudCIAMAESQQoRU3Vic2NyaWJlTWVzc2FnZXMSDS5icmlkZ2UuRW1wdHkaGS5icmlkZ2UuTWVzc2FnZURlYnVnRXZlbnQiADABMtsBCgRBcHBzEjAKBkRlcGxveRIYLmJyaWRnZS5EZXBsb3lBcHBSZXF1ZXN0GgouYnJpZGdlLklEIgASRAoLTGlzdFJ1bm5pbmcSHi5icmlkZ2UuTGlzdFJ1bm5pbmdBcHBzUmVxdWVzdBoTLmJyaWRnZS5SdW5uaW5nQXBwcyIAEi8KBFN0b3ASFi5icmlkZ2UuU3RvcEFwcFJlcXVlc3QaDS5icmlkZ2UuRW1wdHkiABIqCgtHZXRPd25BcHBJZBINLmJyaWRnZS5FbXB0eRoKLmJyaWRnZS5JRCIA");

/**
 * @generated from message bridge.Empty
 */
export type Empty = Message$1<"bridge.Empty"> & {
};

/**
 * Describes the message bridge.Empty.
 * Use `create(EmptySchema)` to create a new message.
 */
export const EmptySchema: GenMessage<Empty> = /*@__PURE__*/
  messageDesc(file_bridge, 0);

/**
 * @generated from message bridge.Data
 */
export type Data = Message$1<"bridge.Data"> & {
  /**
   * @generated from field: required bytes data = 1;
   */
  data: Uint8Array;
};

/**
 * Describes the message bridge.Data.
 * Use `create(DataSchema)` to create a new message.
 */
export const DataSchema: GenMessage<Data> = /*@__PURE__*/
  messageDesc(file_bridge, 1);

/**
 * @generated from message bridge.OptionalData
 */
export type OptionalData = Message$1<"bridge.OptionalData"> & {
  /**
   * @generated from field: optional bridge.Data data = 1;
   */
  data?: Data;
};

/**
 * Describes the message bridge.OptionalData.
 * Use `create(OptionalDataSchema)` to create a new message.
 */
export const OptionalDataSchema: GenMessage<OptionalData> = /*@__PURE__*/
  messageDesc(file_bridge, 2);

/**
 * Unique identifier in the form of a stringified ULID
 *
 * @generated from message bridge.ID
 */
export type ID = Message$1<"bridge.ID"> & {
  /**
   * @generated from field: required string ulid = 1;
   */
  ulid: string;
};

/**
 * Describes the message bridge.ID.
 * Use `create(IDSchema)` to create a new message.
 */
export const IDSchema: GenMessage<ID> = /*@__PURE__*/
  messageDesc(file_bridge, 3);

/**
 * A peer in the network
 *
 * @generated from message bridge.Peer
 */
export type Peer = Message$1<"bridge.Peer"> & {
  /**
   * @generated from field: required string peer_id = 1;
   */
  peerId: string;
};

/**
 * Describes the message bridge.Peer.
 * Use `create(PeerSchema)` to create a new message.
 */
export const PeerSchema: GenMessage<Peer> = /*@__PURE__*/
  messageDesc(file_bridge, 4);

/**
 * The topic of a message
 *
 * @generated from message bridge.Topic
 */
export type Topic = Message$1<"bridge.Topic"> & {
  /**
   * @generated from field: required string topic = 1;
   */
  topic: string;
};

/**
 * Describes the message bridge.Topic.
 * Use `create(TopicSchema)` to create a new message.
 */
export const TopicSchema: GenMessage<Topic> = /*@__PURE__*/
  messageDesc(file_bridge, 5);

/**
 * An optional topic for a message
 *
 * @generated from message bridge.OptionalTopic
 */
export type OptionalTopic = Message$1<"bridge.OptionalTopic"> & {
  /**
   * @generated from field: optional bridge.Topic topic = 1;
   */
  topic?: Topic;
};

/**
 * Describes the message bridge.OptionalTopic.
 * Use `create(OptionalTopicSchema)` to create a new message.
 */
export const OptionalTopicSchema: GenMessage<OptionalTopic> = /*@__PURE__*/
  messageDesc(file_bridge, 6);

/**
 * A query for a topic that can be a regex
 *
 * @generated from message bridge.TopicQuery
 */
export type TopicQuery = Message$1<"bridge.TopicQuery"> & {
  /**
   * @generated from oneof bridge.TopicQuery.query
   */
  query: {
    /**
     * @generated from field: bridge.Topic topic = 1;
     */
    value: Topic;
    case: "topic";
  } | {
    /**
     * @generated from field: string regex = 2;
     */
    value: string;
    case: "regex";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.TopicQuery.
 * Use `create(TopicQuerySchema)` to create a new message.
 */
export const TopicQuerySchema: GenMessage<TopicQuery> = /*@__PURE__*/
  messageDesc(file_bridge, 7);

/**
 * An optional query for a topic
 *
 * @generated from message bridge.OptionalTopicQuery
 */
export type OptionalTopicQuery = Message$1<"bridge.OptionalTopicQuery"> & {
  /**
   * @generated from field: optional bridge.TopicQuery query = 1;
   */
  query?: TopicQuery;
};

/**
 * Describes the message bridge.OptionalTopicQuery.
 * Use `create(OptionalTopicQuerySchema)` to create a new message.
 */
export const OptionalTopicQuerySchema: GenMessage<OptionalTopicQuery> = /*@__PURE__*/
  messageDesc(file_bridge, 8);

/**
 * A message with an optional topic
 *
 * @generated from message bridge.Message
 */
export type Message = Message$1<"bridge.Message"> & {
  /**
   * @generated from field: required bridge.Data data = 1;
   */
  data?: Data;

  /**
   * @generated from field: required bridge.OptionalTopic topic = 2;
   */
  topic?: OptionalTopic;
};

/**
 * Describes the message bridge.Message.
 * Use `create(MessageSchema)` to create a new message.
 */
export const MessageSchema: GenMessage<Message> = /*@__PURE__*/
  messageDesc(file_bridge, 9);

/**
 * A request to a peer with an optional topic
 *
 * @generated from message bridge.SendRequest
 */
export type SendRequest = Message$1<"bridge.SendRequest"> & {
  /**
   * @generated from field: required bridge.Peer peer = 1;
   */
  peer?: Peer;

  /**
   * @generated from field: required bridge.Message msg = 2;
   */
  msg?: Message;
};

/**
 * Describes the message bridge.SendRequest.
 * Use `create(SendRequestSchema)` to create a new message.
 */
export const SendRequestSchema: GenMessage<SendRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 10);

/**
 * A request from a peer with an optional topic
 *
 * @generated from message bridge.RecvRequest
 */
export type RecvRequest = Message$1<"bridge.RecvRequest"> & {
  /**
   * @generated from field: required bridge.Peer peer = 1;
   */
  peer?: Peer;

  /**
   * @generated from field: required bridge.Message msg = 2;
   */
  msg?: Message;

  /**
   * Sequence number for request-response matching
   *
   * @generated from field: required uint64 seq = 3;
   */
  seq: bigint;
};

/**
 * Describes the message bridge.RecvRequest.
 * Use `create(RecvRequestSchema)` to create a new message.
 */
export const RecvRequestSchema: GenMessage<RecvRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 11);

/**
 * A received response to a request or an error
 *
 * @generated from message bridge.Response
 */
export type Response = Message$1<"bridge.Response"> & {
  /**
   * @generated from oneof bridge.Response.response
   */
  response: {
    /**
     * @generated from field: bridge.Data data = 1;
     */
    value: Data;
    case: "data";
  } | {
    /**
     * @generated from field: string error = 2;
     */
    value: string;
    case: "error";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.Response.
 * Use `create(ResponseSchema)` to create a new message.
 */
export const ResponseSchema: GenMessage<Response> = /*@__PURE__*/
  messageDesc(file_bridge, 12);

/**
 * A response to a request
 *
 * @generated from message bridge.SendResponse
 */
export type SendResponse = Message$1<"bridge.SendResponse"> & {
  /**
   * Sequence number for request-response matching
   *
   * @generated from field: required uint64 seq = 1;
   */
  seq: bigint;

  /**
   * @generated from field: required bridge.Response response = 2;
   */
  response?: Response;
};

/**
 * Describes the message bridge.SendResponse.
 * Use `create(SendResponseSchema)` to create a new message.
 */
export const SendResponseSchema: GenMessage<SendResponse> = /*@__PURE__*/
  messageDesc(file_bridge, 13);

/**
 * A list of peers
 *
 * @generated from message bridge.Peers
 */
export type Peers = Message$1<"bridge.Peers"> & {
  /**
   * @generated from field: repeated bridge.Peer peers = 1;
   */
  peers: Peer[];
};

/**
 * Describes the message bridge.Peers.
 * Use `create(PeersSchema)` to create a new message.
 */
export const PeersSchema: GenMessage<Peers> = /*@__PURE__*/
  messageDesc(file_bridge, 14);

/**
 * A neighbour discovery event
 *
 * @generated from message bridge.NeighbourEvent
 */
export type NeighbourEvent = Message$1<"bridge.NeighbourEvent"> & {
  /**
   * @generated from oneof bridge.NeighbourEvent.event
   */
  event: {
    /**
     * @generated from field: bridge.Peers init = 1;
     */
    value: Peers;
    case: "init";
  } | {
    /**
     * @generated from field: bridge.Peer discovered = 2;
     */
    value: Peer;
    case: "discovered";
  } | {
    /**
     * @generated from field: bridge.Peer lost = 3;
     */
    value: Peer;
    case: "lost";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.NeighbourEvent.
 * Use `create(NeighbourEventSchema)` to create a new message.
 */
export const NeighbourEventSchema: GenMessage<NeighbourEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 15);

/**
 * An ID of a message in pub-sub
 *
 * @generated from message bridge.PubSubMessageID
 */
export type PubSubMessageID = Message$1<"bridge.PubSubMessageID"> & {
  /**
   * @generated from field: required bytes id = 1;
   */
  id: Uint8Array;
};

/**
 * Describes the message bridge.PubSubMessageID.
 * Use `create(PubSubMessageIDSchema)` to create a new message.
 */
export const PubSubMessageIDSchema: GenMessage<PubSubMessageID> = /*@__PURE__*/
  messageDesc(file_bridge, 16);

/**
 * A message for publishing in a pub-sub topic
 *
 * @generated from message bridge.PubSubMessage
 */
export type PubSubMessage = Message$1<"bridge.PubSubMessage"> & {
  /**
   * @generated from field: required bridge.Data data = 1;
   */
  data?: Data;

  /**
   * @generated from field: required bridge.Topic topic = 2;
   */
  topic?: Topic;
};

/**
 * Describes the message bridge.PubSubMessage.
 * Use `create(PubSubMessageSchema)` to create a new message.
 */
export const PubSubMessageSchema: GenMessage<PubSubMessage> = /*@__PURE__*/
  messageDesc(file_bridge, 17);

/**
 * A received message from a pub-sub topic
 *
 * @generated from message bridge.PubSubRecvMessage
 */
export type PubSubRecvMessage = Message$1<"bridge.PubSubRecvMessage"> & {
  /**
   * @generated from field: required bridge.Peer propagation_source = 1;
   */
  propagationSource?: Peer;

  /**
   * @generated from field: optional bridge.Peer source = 2;
   */
  source?: Peer;

  /**
   * @generated from field: required bridge.PubSubMessage msg = 3;
   */
  msg?: PubSubMessage;

  /**
   * @generated from field: required bridge.PubSubMessageID msg_id = 4;
   */
  msgId?: PubSubMessageID;
};

/**
 * Describes the message bridge.PubSubRecvMessage.
 * Use `create(PubSubRecvMessageSchema)` to create a new message.
 */
export const PubSubRecvMessageSchema: GenMessage<PubSubRecvMessage> = /*@__PURE__*/
  messageDesc(file_bridge, 18);

/**
 * A DHT key with a topic
 *
 * @generated from message bridge.DHTKey
 */
export type DHTKey = Message$1<"bridge.DHTKey"> & {
  /**
   * @generated from field: required bridge.Topic topic = 1;
   */
  topic?: Topic;

  /**
   * @generated from field: required bytes key = 2;
   */
  key: Uint8Array;
};

/**
 * Describes the message bridge.DHTKey.
 * Use `create(DHTKeySchema)` to create a new message.
 */
export const DHTKeySchema: GenMessage<DHTKey> = /*@__PURE__*/
  messageDesc(file_bridge, 19);

/**
 * A record for putting in the DHT
 *
 * @generated from message bridge.DHTRecord
 */
export type DHTRecord = Message$1<"bridge.DHTRecord"> & {
  /**
   * @generated from field: required bridge.DHTKey key = 1;
   */
  key?: DHTKey;

  /**
   * @generated from field: required bridge.Data value = 2;
   */
  value?: Data;
};

/**
 * Describes the message bridge.DHTRecord.
 * Use `create(DHTRecordSchema)` to create a new message.
 */
export const DHTRecordSchema: GenMessage<DHTRecord> = /*@__PURE__*/
  messageDesc(file_bridge, 20);

/**
 * A key-value pair for putting into the local key-value store
 *
 * @generated from message bridge.LocalKVRecord
 */
export type LocalKVRecord = Message$1<"bridge.LocalKVRecord"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;

  /**
   * @generated from field: required bridge.Data value = 2;
   */
  value?: Data;
};

/**
 * Describes the message bridge.LocalKVRecord.
 * Use `create(LocalKVRecordSchema)` to create a new message.
 */
export const LocalKVRecordSchema: GenMessage<LocalKVRecord> = /*@__PURE__*/
  messageDesc(file_bridge, 21);

/**
 * A key for getting a value from the local key-value store
 *
 * @generated from message bridge.LocalKVKey
 */
export type LocalKVKey = Message$1<"bridge.LocalKVKey"> & {
  /**
   * @generated from field: required string key = 1;
   */
  key: string;
};

/**
 * Describes the message bridge.LocalKVKey.
 * Use `create(LocalKVKeySchema)` to create a new message.
 */
export const LocalKVKeySchema: GenMessage<LocalKVKey> = /*@__PURE__*/
  messageDesc(file_bridge, 22);

/**
 * A file path on the local filesystem
 *
 * @generated from message bridge.FilePath
 */
export type FilePath = Message$1<"bridge.FilePath"> & {
  /**
   * @generated from field: required string path = 1;
   */
  path: string;
};

/**
 * Describes the message bridge.FilePath.
 * Use `create(FilePathSchema)` to create a new message.
 */
export const FilePathSchema: GenMessage<FilePath> = /*@__PURE__*/
  messageDesc(file_bridge, 23);

/**
 * The cid of a file
 *
 * @generated from message bridge.CID
 */
export type CID = Message$1<"bridge.CID"> & {
  /**
   * @generated from field: required bytes hash = 1;
   */
  hash: Uint8Array;

  /**
   * @generated from field: required bridge.ID id = 2;
   */
  id?: ID;
};

/**
 * Describes the message bridge.CID.
 * Use `create(CIDSchema)` to create a new message.
 */
export const CIDSchema: GenMessage<CID> = /*@__PURE__*/
  messageDesc(file_bridge, 24);

/**
 * A download event
 *
 * The progress field is a percentage of the download progress
 *
 * @generated from message bridge.DownloadEvent
 */
export type DownloadEvent = Message$1<"bridge.DownloadEvent"> & {
  /**
   * @generated from oneof bridge.DownloadEvent.event
   */
  event: {
    /**
     * @generated from field: uint64 progress = 1;
     */
    value: bigint;
    case: "progress";
  } | {
    /**
     * @generated from field: bridge.FilePath ready = 2;
     */
    value: FilePath;
    case: "ready";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.DownloadEvent.
 * Use `create(DownloadEventSchema)` to create a new message.
 */
export const DownloadEventSchema: GenMessage<DownloadEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 25);

/**
 * A mesh topology event
 *
 * @generated from message bridge.MeshTopologyEvent
 */
export type MeshTopologyEvent = Message$1<"bridge.MeshTopologyEvent"> & {
  /**
   * @generated from field: required bridge.Peer peer = 1;
   */
  peer?: Peer;

  /**
   * @generated from field: required bridge.NeighbourEvent event = 2;
   */
  event?: NeighbourEvent;
};

/**
 * Describes the message bridge.MeshTopologyEvent.
 * Use `create(MeshTopologyEventSchema)` to create a new message.
 */
export const MeshTopologyEventSchema: GenMessage<MeshTopologyEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 26);

/**
 * A request debug event
 *
 * @generated from message bridge.RequestDebugEvent
 */
export type RequestDebugEvent = Message$1<"bridge.RequestDebugEvent"> & {
  /**
   * @generated from field: required bridge.ID id = 1;
   */
  id?: ID;

  /**
   * @generated from field: required bridge.Peer receiver = 2;
   */
  receiver?: Peer;

  /**
   * @generated from field: required bridge.Message msg = 3;
   */
  msg?: Message;
};

/**
 * Describes the message bridge.RequestDebugEvent.
 * Use `create(RequestDebugEventSchema)` to create a new message.
 */
export const RequestDebugEventSchema: GenMessage<RequestDebugEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 27);

/**
 * A response debug event
 *
 * @generated from message bridge.ResponseDebugEvent
 */
export type ResponseDebugEvent = Message$1<"bridge.ResponseDebugEvent"> & {
  /**
   * @generated from field: required bridge.ID req_id = 1;
   */
  reqId?: ID;

  /**
   * @generated from field: required bridge.Response response = 2;
   */
  response?: Response;
};

/**
 * Describes the message bridge.ResponseDebugEvent.
 * Use `create(ResponseDebugEventSchema)` to create a new message.
 */
export const ResponseDebugEventSchema: GenMessage<ResponseDebugEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 28);

/**
 * A message debug event
 *
 * @generated from message bridge.MessageDebugEvent
 */
export type MessageDebugEvent = Message$1<"bridge.MessageDebugEvent"> & {
  /**
   * @generated from field: required bridge.Peer sender = 1;
   */
  sender?: Peer;

  /**
   * @generated from oneof bridge.MessageDebugEvent.event
   */
  event: {
    /**
     * @generated from field: bridge.RequestDebugEvent req = 2;
     */
    value: RequestDebugEvent;
    case: "req";
  } | {
    /**
     * @generated from field: bridge.ResponseDebugEvent res = 3;
     */
    value: ResponseDebugEvent;
    case: "res";
  } | {
    /**
     * @generated from field: bridge.PubSubMessage pub_sub = 4;
     */
    value: PubSubMessage;
    case: "pubSub";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message bridge.MessageDebugEvent.
 * Use `create(MessageDebugEventSchema)` to create a new message.
 */
export const MessageDebugEventSchema: GenMessage<MessageDebugEvent> = /*@__PURE__*/
  messageDesc(file_bridge, 29);

/**
 * A docker image
 *
 * @generated from message bridge.DockerImage
 */
export type DockerImage = Message$1<"bridge.DockerImage"> & {
  /**
   * @generated from field: required string name = 1;
   */
  name: string;
};

/**
 * Describes the message bridge.DockerImage.
 * Use `create(DockerImageSchema)` to create a new message.
 */
export const DockerImageSchema: GenMessage<DockerImage> = /*@__PURE__*/
  messageDesc(file_bridge, 30);

/**
 * A docker app
 *
 * @generated from message bridge.DockerApp
 */
export type DockerApp = Message$1<"bridge.DockerApp"> & {
  /**
   * @generated from field: required bridge.DockerImage image = 1;
   */
  image?: DockerImage;

  /**
   * @generated from field: repeated uint32 ports = 2;
   */
  ports: number[];
};

/**
 * Describes the message bridge.DockerApp.
 * Use `create(DockerAppSchema)` to create a new message.
 */
export const DockerAppSchema: GenMessage<DockerApp> = /*@__PURE__*/
  messageDesc(file_bridge, 31);

/**
 * A request to deploy an app to a peer
 *
 * @generated from message bridge.DeployAppRequest
 */
export type DeployAppRequest = Message$1<"bridge.DeployAppRequest"> & {
  /**
   * @generated from field: required bridge.DockerApp app = 1;
   */
  app?: DockerApp;

  /**
   * @generated from field: required bool local = 2;
   */
  local: boolean;

  /**
   * The peer can be empty if the app should be deployed to self
   *
   * @generated from field: optional bridge.Peer peer = 3;
   */
  peer?: Peer;

  /**
   * @generated from field: required bool persistent = 4;
   */
  persistent: boolean;
};

/**
 * Describes the message bridge.DeployAppRequest.
 * Use `create(DeployAppRequestSchema)` to create a new message.
 */
export const DeployAppRequestSchema: GenMessage<DeployAppRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 32);

/**
 * A request to list running apps on a peer
 *
 * @generated from message bridge.ListRunningAppsRequest
 */
export type ListRunningAppsRequest = Message$1<"bridge.ListRunningAppsRequest"> & {
  /**
   * The peer can be empty if the apps running on self should be listed
   *
   * @generated from field: optional bridge.Peer peer = 1;
   */
  peer?: Peer;
};

/**
 * Describes the message bridge.ListRunningAppsRequest.
 * Use `create(ListRunningAppsRequestSchema)` to create a new message.
 */
export const ListRunningAppsRequestSchema: GenMessage<ListRunningAppsRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 33);

/**
 * An app that is running on a peer
 *
 * @generated from message bridge.RunningApp
 */
export type RunningApp = Message$1<"bridge.RunningApp"> & {
  /**
   * @generated from field: required bridge.ID id = 1;
   */
  id?: ID;

  /**
   * @generated from field: required bridge.DockerImage image = 2;
   */
  image?: DockerImage;

  /**
   * @generated from field: optional string name = 3;
   */
  name: string;
};

/**
 * Describes the message bridge.RunningApp.
 * Use `create(RunningAppSchema)` to create a new message.
 */
export const RunningAppSchema: GenMessage<RunningApp> = /*@__PURE__*/
  messageDesc(file_bridge, 34);

/**
 * A list of running apps
 *
 * @generated from message bridge.RunningApps
 */
export type RunningApps = Message$1<"bridge.RunningApps"> & {
  /**
   * @generated from field: repeated bridge.RunningApp apps = 1;
   */
  apps: RunningApp[];
};

/**
 * Describes the message bridge.RunningApps.
 * Use `create(RunningAppsSchema)` to create a new message.
 */
export const RunningAppsSchema: GenMessage<RunningApps> = /*@__PURE__*/
  messageDesc(file_bridge, 35);

/**
 * A request to stop a running app on a peer
 *
 * @generated from message bridge.StopAppRequest
 */
export type StopAppRequest = Message$1<"bridge.StopAppRequest"> & {
  /**
   * @generated from field: required bridge.ID id = 1;
   */
  id?: ID;

  /**
   * The peer can be empty if the app should be stopped on self
   *
   * @generated from field: optional bridge.Peer peer = 2;
   */
  peer?: Peer;
};

/**
 * Describes the message bridge.StopAppRequest.
 * Use `create(StopAppRequestSchema)` to create a new message.
 */
export const StopAppRequestSchema: GenMessage<StopAppRequest> = /*@__PURE__*/
  messageDesc(file_bridge, 36);

/**
 * @generated from service bridge.ReqResp
 */
export const ReqResp: GenService<{
  /**
   * Send a request with an optional topic to a peer and wait for a response
   *
   * @generated from rpc bridge.ReqResp.Send
   */
  send: {
    methodKind: "unary";
    input: typeof SendRequestSchema;
    output: typeof ResponseSchema;
  },
  /**
   * Receive requests from peers that either have no topic or have a topic that
   * has been subscribed to
   *
   * @generated from rpc bridge.ReqResp.Recv
   */
  recv: {
    methodKind: "server_streaming";
    input: typeof OptionalTopicQuerySchema;
    output: typeof RecvRequestSchema;
  },
  /**
   * Respond to a request received from Recv
   *
   * @generated from rpc bridge.ReqResp.Respond
   */
  respond: {
    methodKind: "unary";
    input: typeof SendResponseSchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 0);

/**
 * @generated from service bridge.Neighbours
 */
export const Neighbours: GenService<{
  /**
   * Subscribe to neighbour discovery events to get notified when new neighbour
   * peers are discovered or lost
   *
   * @generated from rpc bridge.Neighbours.Subscribe
   */
  subscribe: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof NeighbourEventSchema;
  },
  /**
   * Get the neighbours of the current runtime
   *
   * @generated from rpc bridge.Neighbours.Get
   */
  get: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof PeersSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 1);

/**
 * @generated from service bridge.PubSub
 */
export const PubSub: GenService<{
  /**
   * Subscribe to a pub-sub topic to receive messages published in that topic
   *
   * @generated from rpc bridge.PubSub.Subscribe
   */
  subscribe: {
    methodKind: "server_streaming";
    input: typeof TopicSchema;
    output: typeof PubSubRecvMessageSchema;
  },
  /**
   * Publish a message in a pub-sub topic
   *
   * @generated from rpc bridge.PubSub.Publish
   */
  publish: {
    methodKind: "unary";
    input: typeof PubSubMessageSchema;
    output: typeof PubSubMessageIDSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 2);

/**
 * @generated from service bridge.KV
 */
export const KV: GenService<{
  /**
   * Put a record into the global key-value store
   *
   * @generated from rpc bridge.KV.PutRecord
   */
  putRecord: {
    methodKind: "unary";
    input: typeof DHTRecordSchema;
    output: typeof EmptySchema;
  },
  /**
   * Get a record from the global key-value store.
   * The value of the record will be empty if the key is not found.
   *
   * @generated from rpc bridge.KV.GetRecord
   */
  getRecord: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof OptionalDataSchema;
  },
  /**
   * Remove a record from the global key-value store.
   * This only has local effects and only affects the key-value store once the
   * records expire.
   *
   * @generated from rpc bridge.KV.RemoveRecord
   */
  removeRecord: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 3);

/**
 * @generated from service bridge.Discovery
 */
export const Discovery: GenService<{
  /**
   * Mark the current runtime as a provider for a discovery key
   *
   * @generated from rpc bridge.Discovery.Provide
   */
  provide: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof EmptySchema;
  },
  /**
   * Get the providers of a discovery key
   *
   * @generated from rpc bridge.Discovery.GetProviders
   */
  getProviders: {
    methodKind: "server_streaming";
    input: typeof DHTKeySchema;
    output: typeof PeerSchema;
  },
  /**
   * Stop providing a discovery key.
   * This only has local effects and only affects other hyveOS nodes once the
   * providers records expire.
   *
   * @generated from rpc bridge.Discovery.StopProviding
   */
  stopProviding: {
    methodKind: "unary";
    input: typeof DHTKeySchema;
    output: typeof EmptySchema;
  },
  /**
   * Get the peer id of the current runtime
   *
   * @generated from rpc bridge.Discovery.GetOwnId
   */
  getOwnId: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof PeerSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 4);

/**
 * @generated from service bridge.LocalKV
 */
export const LocalKV: GenService<{
  /**
   * Put a record into the local key-value store and get the previous value if
   * it exists. This only has local effects but will be persisted across
   * restarts.
   *
   * @generated from rpc bridge.LocalKV.Put
   */
  put: {
    methodKind: "unary";
    input: typeof LocalKVRecordSchema;
    output: typeof OptionalDataSchema;
  },
  /**
   * Get a record from the local key-value store.
   * This will not return records from other hyveOS nodes.
   *
   * @generated from rpc bridge.LocalKV.Get
   */
  get: {
    methodKind: "unary";
    input: typeof LocalKVKeySchema;
    output: typeof OptionalDataSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 5);

/**
 * @generated from service bridge.FileTransfer
 */
export const FileTransfer: GenService<{
  /**
   * Publish a file in the runtime and get the cid of the file
   *
   * @generated from rpc bridge.FileTransfer.Publish
   */
  publish: {
    methodKind: "unary";
    input: typeof FilePathSchema;
    output: typeof CIDSchema;
  },
  /**
   * Request a file with a cid from the runtime
   *
   * @generated from rpc bridge.FileTransfer.Get
   */
  get: {
    methodKind: "unary";
    input: typeof CIDSchema;
    output: typeof FilePathSchema;
  },
  /**
   * Request a file with a cid from the runtime and get notified about the
   * download progress
   *
   * @generated from rpc bridge.FileTransfer.GetWithProgress
   */
  getWithProgress: {
    methodKind: "server_streaming";
    input: typeof CIDSchema;
    output: typeof DownloadEventSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 6);

/**
 * @generated from service bridge.Debug
 */
export const Debug: GenService<{
  /**
   * Subscribe to mesh topology events to get notified when the mesh topology
   * changes
   *
   * @generated from rpc bridge.Debug.SubscribeMeshTopology
   */
  subscribeMeshTopology: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof MeshTopologyEventSchema;
  },
  /**
   * Subscribe to message debug events to get notified when messages are sent
   *
   * @generated from rpc bridge.Debug.SubscribeMessages
   */
  subscribeMessages: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof MessageDebugEventSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 7);

/**
 * @generated from service bridge.Apps
 */
export const Apps: GenService<{
  /**
   * Deploy an app to a peer and get the id of the deployed app
   *
   * @generated from rpc bridge.Apps.Deploy
   */
  deploy: {
    methodKind: "unary";
    input: typeof DeployAppRequestSchema;
    output: typeof IDSchema;
  },
  /**
   * List running apps on a peer
   *
   * @generated from rpc bridge.Apps.ListRunning
   */
  listRunning: {
    methodKind: "unary";
    input: typeof ListRunningAppsRequestSchema;
    output: typeof RunningAppsSchema;
  },
  /**
   * Stop a running app on a peer
   *
   * @generated from rpc bridge.Apps.Stop
   */
  stop: {
    methodKind: "unary";
    input: typeof StopAppRequestSchema;
    output: typeof EmptySchema;
  },
  /**
   * Get the id of the current app
   *
   * @generated from rpc bridge.Apps.GetOwnAppId
   */
  getOwnAppId: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof IDSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_bridge, 8);

